warning: in the working copy of 'src/task/entities/task.entity.ts', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/task/task.service.ts', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/tbm/entities/tbm.entity.ts', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/tool/dto/create-tool.dto.ts', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/tool/entities/tool.entity.ts', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/tool/tool.controller.ts', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/tool/tool.service.ts', LF will be replaced by CRLF the next time Git touches it
diff --git a/src/task/entities/task.entity.ts b/src/task/entities/task.entity.ts
index a185ee8..be6b79c 100644
--- a/src/task/entities/task.entity.ts
+++ b/src/task/entities/task.entity.ts
@@ -1,43 +1,41 @@
-import {
-       Column,
-       Entity,
-       JoinColumn, JoinTable,
-       ManyToMany,
-       ManyToOne,
-       PrimaryGeneratedColumn,
-} from 'typeorm';
+import { Entity, PrimaryGeneratedColumn, Column, ManyToMany, JoinTable, ManyToOne, JoinColumn } from 'typeorm';
 import { BaseTable } from '../../common/entity/base-table.entity';
 import { Workshop } from '../../workshop/entities/workshop.entity';
 import { Company } from '../../company/entities/company.entity';
-import { Exclude } from 'class-transformer';
 import { Tool } from '../../tool/entities/tool.entity';
+import { Tbm } from '../../tbm/entities/tbm.entity'; // 추가
+import { Exclude } from 'class-transformer';
 @Entity()
 export class Task extends BaseTable {
-       @PrimaryGeneratedColumn()
-       id: number;
+  @PrimaryGeneratedColumn()
+  id: number;
+
+  @Column()
+  title: string;
-       @Column()
-       title: string;
+  @Column({
+    nullable: true,
+    type: 'text',
+  })
+  description: string;
-       @Column({
-               nullable: true,
-               type: 'text',
-       })
-       description: string;
+  @ManyToMany(() => Workshop, (workshop) => workshop.tasks)
+  workshops: Workshop[];
-       @ManyToMany(() => Workshop, (workshop) => workshop.tasks)
-       workshops: Workshop[];
+  @Column()
+  @Exclude()
+  companyId: number;
-       @Column()
-       @Exclude()
-       companyId: number;
+  @ManyToOne(() => Company, (company) => company.tasks)
+  @JoinColumn({ name: 'companyId' })
+  company: Company;
-       @ManyToOne(() => Company, (company) => company.tasks)
-       @JoinColumn({ name: 'companyId' })
-       company: Company;
+  @ManyToMany(() => Tool, (tool) => tool.tasks)
+  @JoinTable()
+  tools: Tool[];
-       @ManyToMany(() => Tool, (tool) => tool.tasks)
-       @JoinTable()
-       tools: Tool[]
-}
+  // Tbm과의 다대다 관계 (조인 테이블 소유측)
+  @ManyToMany(() => Tbm, (tbm) => tbm.tasks)
+  tbms: Tbm[];
+}
\ No newline at end of file
diff --git a/src/task/task.service.ts b/src/task/task.service.ts
index 32974dc..416c358 100644
--- a/src/task/task.service.ts
+++ b/src/task/task.service.ts
@@ -175,7 +175,7 @@ export class TaskService {
                });
                if (!tools.length) {
-                       throw new NotFoundException('tasks not found');
+                       throw new NotFoundException('tools not found');
                }
                task.tools = tools;
diff --git a/src/tbm/dto/create-tbm.dto.ts b/src/tbm/dto/create-tbm.dto.ts
index 2cf0dcd..d0d6f7c 100644
--- a/src/tbm/dto/create-tbm.dto.ts
+++ b/src/tbm/dto/create-tbm.dto.ts
@@ -1 +1,19 @@
-export class CreateTbmDto {}
+import { IsArray, IsInt, IsNotEmpty, IsOptional, IsString, Min } from 'class-validator';
+
+export class CreateTbmDto {
+       @IsNotEmpty()
+       @IsString()
+       name: string;
+
+       @IsNotEmpty()
+       @IsString()
+       content: string;
+
+       @IsInt()
+       @Min(1)
+       workshopId: number;
+
+       @IsOptional()
+       @IsArray()
+       taskIds?: number[];
+}
diff --git a/src/tbm/entities/tbm.entity.ts b/src/tbm/entities/tbm.entity.ts
index f8a94ce..87e745c 100644
--- a/src/tbm/entities/tbm.entity.ts
+++ b/src/tbm/entities/tbm.entity.ts
@@ -1,22 +1,35 @@
-import { Column, Entity, ManyToOne, PrimaryGeneratedColumn } from 'typeorm';
+import {
+       Column,
+       Entity,
+       JoinColumn,
+       ManyToOne,
+       PrimaryGeneratedColumn,
+       ManyToMany, JoinTable, // 추가
+} from 'typeorm';
 import { Workshop } from '../../workshop/entities/workshop.entity';
 import { BaseTable } from '../../common/entity/base-table.entity';
+import { Task } from '../../task/entities/task.entity'; // 추가
 @Entity()
 export class Tbm extends BaseTable {
-       @PrimaryGeneratedColumn()
-       id: number;
+  @PrimaryGeneratedColumn()
+  id: number;
-       @Column()
-       name: string;
+  @Column()
+  name: string;
-       @Column()
-       content: string;
+  @Column()
+  content: string;
-       @Column()
-       workshopId: number;
+  @Column()
+  workshopId: number;
-       @ManyToOne(() => Workshop, (workshop) => workshop.tbms)
-       workshop: Workshop;
+  @ManyToOne(() => Workshop, (workshop) => workshop.tbms)
+  @JoinColumn({ name: 'workshopId' })
+  workshop: Workshop;
-}
+  // Task와의 다대다 관계 (역방향)
+  @ManyToMany(() => Task, (task) => task.tbms)
+       @JoinTable()
+  tasks: Task[];
+}
\ No newline at end of file
diff --git a/src/tbm/tbm.module.ts b/src/tbm/tbm.module.ts
index aa812cf..9eefa1a 100644
--- a/src/tbm/tbm.module.ts
+++ b/src/tbm/tbm.module.ts
@@ -1,8 +1,13 @@
 import { Module } from '@nestjs/common';
 import { TbmService } from './tbm.service';
 import { TbmController } from './tbm.controller';
+import { TypeOrmModule } from '@nestjs/typeorm';
+import { Tbm } from './entities/tbm.entity';
+import { Task } from '../task/entities/task.entity';
+import { Workshop } from '../workshop/entities/workshop.entity';
 @Module({
+  imports: [TypeOrmModule.forFeature([Tbm, Task, Workshop])],
   controllers: [TbmController],
   providers: [TbmService],
 })
diff --git a/src/tbm/tbm.service.ts b/src/tbm/tbm.service.ts
index b7d5b7c..9d4c8b1 100644
--- a/src/tbm/tbm.service.ts
+++ b/src/tbm/tbm.service.ts
@@ -1,26 +1,86 @@
-import { Injectable } from '@nestjs/common';
+import { Injectable, NotFoundException } from '@nestjs/common';
+import { InjectRepository } from '@nestjs/typeorm';
+import { In, Repository } from 'typeorm';
 import { CreateTbmDto } from './dto/create-tbm.dto';
 import { UpdateTbmDto } from './dto/update-tbm.dto';
+import { Tbm } from './entities/tbm.entity';
+import { Task } from '../task/entities/task.entity';
+import { Workshop } from '../workshop/entities/workshop.entity';
 @Injectable()
 export class TbmService {
-  create(createTbmDto: CreateTbmDto) {
-    return 'This action adds a new tbm';
+  constructor(
+    @InjectRepository(Tbm)
+    private readonly tbmRepository: Repository<Tbm>,
+    @InjectRepository(Task)
+    private readonly taskRepository: Repository<Task>,
+    @InjectRepository(Workshop)
+    private readonly workshopRepository: Repository<Workshop>,
+  ) {}
+
+  async create(createTbmDto: CreateTbmDto) {
+    const workshop = await this.workshopRepository.findOne({ where: { id: createTbmDto.workshopId } });
+    if (!workshop) {
+      throw new NotFoundException('Workshop not found');
+    }
+
+    const tbm = this.tbmRepository.create({
+      name: createTbmDto.name,
+      content: createTbmDto.content,
+      workshopId: createTbmDto.workshopId,
+    });
+
+    if (createTbmDto.taskIds && createTbmDto.taskIds.length) {
+      const tasks = await this.taskRepository.findBy({ id: In(createTbmDto.taskIds) });
+      tbm.tasks = tasks;
+    }
+
+    return this.tbmRepository.save(tbm);
   }
   findAll() {
-    return `This action returns all tbm`;
+    return this.tbmRepository.find({ where: { }, relations: ['tasks'] });
   }
-  findOne(id: number) {
-    return `This action returns a #${id} tbm`;
+  async findOne(id: number) {
+    const tbm = await this.tbmRepository.findOne({ where: { id }, relations: ['tasks'] });
+    if (!tbm) {
+      throw new NotFoundException('Tbm not found');
+    }
+    return tbm;
   }
-  update(id: number, updateTbmDto: UpdateTbmDto) {
-    return `This action updates a #${id} tbm`;
+  async update(id: number, updateTbmDto: UpdateTbmDto) {
+    const tbm = await this.tbmRepository.findOne({ where: { id }, relations: ['tasks'] });
+    if (!tbm) {
+      throw new NotFoundException('Tbm not found');
+    }
+
+    if (updateTbmDto.taskIds) {
+      const tasks = await this.taskRepository.findBy({ id: In(updateTbmDto.taskIds) });
+      tbm.tasks = tasks;
+    }
+
+    // assign scalar fields
+    if (typeof updateTbmDto.name !== 'undefined') tbm.name = updateTbmDto.name;
+    if (typeof updateTbmDto.content !== 'undefined') tbm.content = updateTbmDto.content;
+    if (typeof updateTbmDto.workshopId !== 'undefined') {
+      const workshop = await this.workshopRepository.findOne({ where: { id: updateTbmDto.workshopId } });
+      if (!workshop) {
+        throw new NotFoundException('Workshop not found');
+      }
+      tbm.workshopId = updateTbmDto.workshopId;
+    }
+
+    return this.tbmRepository.save(tbm);
   }
-  remove(id: number) {
-    return `This action removes a #${id} tbm`;
+  async remove(id: number) {
+    const tbm = await this.tbmRepository.findOne({ where: { id } });
+    if (!tbm) {
+      throw new NotFoundException('Tbm not found');
+    }
+    await this.tbmRepository.softRemove(tbm);
+    return id;
   }
 }
diff --git a/src/tool/dto/create-tool.dto.ts b/src/tool/dto/create-tool.dto.ts
index bae8cdd..94e055e 100644
--- a/src/tool/dto/create-tool.dto.ts
+++ b/src/tool/dto/create-tool.dto.ts
@@ -1,4 +1,4 @@
-import { IsNotEmpty, IsNumber, IsOptional, IsString } from 'class-validator';
+import { IsNotEmpty, IsOptional, IsString } from 'class-validator';
 export class CreateToolDto {
        @IsNotEmpty()
@@ -8,8 +8,4 @@ export class CreateToolDto {
        @IsOptional()
        @IsString()
        manual: string;
-
-       @IsNotEmpty()
-       @IsNumber()
-       companyId: number;
 }
diff --git a/src/tool/entities/tool.entity.ts b/src/tool/entities/tool.entity.ts
index 8cc5d44..f69ff83 100644
--- a/src/tool/entities/tool.entity.ts
+++ b/src/tool/entities/tool.entity.ts
@@ -3,6 +3,7 @@ import {
        Column,
        Entity,
        JoinColumn,
+       ManyToMany,
        ManyToOne,
        PrimaryGeneratedColumn,
 } from 'typeorm';
@@ -26,7 +27,7 @@ export class Tool extends BaseTable {
        @Column()
        companyId: number;
-       @ManyToOne(() => Task, (task) => task.tools)
+       @ManyToMany(() => Task, (task) => task.tools)
        tasks: Task[];
        @ManyToOne(() => Company, (company) => company.tools)
diff --git a/src/tool/tool.controller.ts b/src/tool/tool.controller.ts
index fa4e445..5c17f16 100644
--- a/src/tool/tool.controller.ts
+++ b/src/tool/tool.controller.ts
@@ -1,12 +1,16 @@
 import {
-       Body, ClassSerializerInterceptor,
+       Body,
+       ClassSerializerInterceptor,
        Controller,
        Delete,
        Get,
        Param,
+       ParseArrayPipe,
        Patch,
        Post,
-       Request, UseInterceptors,
+       Query,
+       Request,
+       UseInterceptors,
 } from '@nestjs/common';
 import { ToolService } from './tool.service';
 import { CreateToolDto } from './dto/create-tool.dto';
@@ -18,12 +22,12 @@ export class ToolController {
        constructor(private readonly toolService: ToolService) {}
        @Post()
-       create(@Body() createToolDto: CreateToolDto) {
-               return this.toolService.create(createToolDto);
+       create(@Request() req: any, @Body() createToolDto: CreateToolDto) {
+               return this.toolService.create(req.user.companyId, createToolDto);
        }
        @Get()
-       findAll(@Request() req) {
+       findAll(@Request() req: any) {
                return this.toolService.findAll(req);
        }
@@ -32,11 +36,24 @@ export class ToolController {
                return this.toolService.findOne(+id);
        }
+       @Get(':taskId/task')
+       findByTask(@Param('taskId') taskId: string, @Query('name') name?: string) {
+               return this.toolService.findByTask(+taskId, name);
+       }
+
        @Patch(':id')
        update(@Param('id') id: string, @Body() updateToolDto: UpdateToolDto) {
                return this.toolService.update(+id, updateToolDto);
        }
+       @Delete('multiple')
+       removeMultiple(
+               @Body('ids', new ParseArrayPipe({ items: Number, separator: ',' }))
+               ids: number[],
+       ) {
+               return this.toolService.removeMultiple(ids);
+       }
+
        @Delete(':id')
        remove(@Param('id') id: string) {
                return this.toolService.remove(+id);
diff --git a/src/tool/tool.service.ts b/src/tool/tool.service.ts
index 6339bc6..1205aa8 100644
--- a/src/tool/tool.service.ts
+++ b/src/tool/tool.service.ts
@@ -1,44 +1,129 @@
-import { Injectable } from '@nestjs/common';
+import { Injectable, NotFoundException } from '@nestjs/common';
 import { CreateToolDto } from './dto/create-tool.dto';
 import { UpdateToolDto } from './dto/update-tool.dto';
 import { UserRole } from '../users/entities/user.entity';
 import { Tool } from './entities/tool.entity';
-import { Repository } from 'typeorm';
+import { In, Repository } from 'typeorm';
 import { InjectRepository } from '@nestjs/typeorm';
+import { Task } from '../task/entities/task.entity';
 @Injectable()
 export class ToolService {
        constructor(
                @InjectRepository(Tool)
                private readonly toolRepository: Repository<Tool>,
+               @InjectRepository(Task)
+               private readonly taskRepository: Repository<Task>,
        ) {}
-       create(createToolDto: CreateToolDto) {
+       async create(companyId: number, createToolDto: CreateToolDto) {
+               const tools = await this.toolRepository.find({
+                       where: {
+                               name: createToolDto.name,
+                               companyId: companyId,
+                       },
+               });
+               if (tools.length > 0) {
+                       throw new NotFoundException('장비 이름이 중복되었습니다.');
+               }
+               const tool = this.toolRepository.create({ ...createToolDto, companyId });
-               return 'This action adds a new tool';
+               return await this.toolRepository.save(tool);
        }
-       async findAll(req) {
+       async findAll(req: any) {
                const qb = this.toolRepository
                        .createQueryBuilder('tool')
                        .where('tool.deletedAt IS NULL');
+
                if (req.user.role !== UserRole.MASTER) {
                        qb.andWhere('tool.companyId = :id', { id: req.user.companyId });
                }
-               await qb.getMany();
                return await qb.getMany();
        }
-       findOne(id: number) {
-               return `This action returns a #${id} tool`;
+       async findOne(id: number) {
+               const tool = await this.toolRepository.findOne({ where: { id } });
+
+               if (!tool) {
+                       throw new NotFoundException('Tool not found');
+               }
+
+               return tool;
+       }
+
+       async findByTask(taskId: number, name?: string) {
+               // 워크샵 정보와 연관된 작업들 조회
+               const task = await this.taskRepository.findOne({
+                       where: { id: taskId },
+                       relations: ['tools'],
+               });
+
+               if (!task) {
+                       throw new NotFoundException('task not found');
+               }
+
+               const assignedTaskIds = new Set(task.tools.map((tool) => tool.id));
+
+               const qb = this.toolRepository.createQueryBuilder('tool');
+
+               qb.where('tool.deletedAt IS NULL');
+
+               qb.andWhere('tool.companyId = :companyId', {
+                       companyId: task.companyId,
+               });
+
+               if (name) {
+                       qb.andWhere('tool.name LIKE :name', { name: `%${name}%` });
+               }
+               const allTasks = await qb.getMany();
+
+               console.log(allTasks);
+
+               return allTasks.map((tool) => ({
+                       id: tool.id,
+                       name: tool.name,
+                       isActivated: assignedTaskIds.has(tool.id),
+               }));
+       }
+
+       async update(id: number, updateToolDto: UpdateToolDto) {
+               const tool = await this.toolRepository.findOne({ where: { id } });
+
+               if (!tool) {
+                       throw new NotFoundException('Tool not found');
+               }
+
+               await this.toolRepository.update(id, updateToolDto);
+               return await this.toolRepository.findOne({ where: { id } });
        }
-       update(id: number, updateToolDto: UpdateToolDto) {
-               return `This action updates a #${id} tool`;
+       async remove(id: number) {
+               const tool = await this.toolRepository.findOne({ where: { id } });
+
+               if (!tool) {
+                       throw new NotFoundException('Tool not found');
+               }
+
+               await this.toolRepository.softRemove(tool);
+               return id;
        }
-       remove(id: number) {
-               return `This action removes a #${id} tool`;
+       async removeMultiple(ids: number[]) {
+               const tools = await this.toolRepository.find({
+                       where: { id: In(ids) },
+               });
+
+               if (tools.length === 0) {
+                       throw new NotFoundException('삭제할 작업이 없습니다.');
+               }
+
+               if (tools.length !== ids.length) {
+                       throw new NotFoundException('일부 작업을 찾을 수 없습니 다.');
+               }
+
+               await this.toolRepository.softRemove(tools);
+               return tools.map((tool) => tool.id); // 실제 삭제된 ID만 리턴
        }
 }